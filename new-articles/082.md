# BootstrapVue: What if I want to refactor scoped field slots in tables

## First: The problem

Have you used [BootstrapVue](https://bootstrap-vue.org) before? If so, you may have known, that you can control what a cell should looks like in a table by using [scoped field slots](https://bootstrap-vue.org/docs/components/table#scoped-field-slots).

Simply said, you can use `&lt;template #cell(prop)=""&gt;` on `&lt;b-table&gt;` template; and add a `["prop"]` item to `fields` property. Like [example](https://bootstrap-vue.org/docs/components/table#scoped-field-slots) shows:

```vue
&lt;template&gt;
    &lt;div&gt;
        &lt;b-table small :fields="fields" :items="items" responsive="sm"&gt;
            &lt;!-- A virtual column --&gt;
            &lt;template #cell(index)="data"&gt;
                {{ data.index + 1 }}
            &lt;/template&gt;

            &lt;!-- A custom formatted column --&gt;
            &lt;template #cell(name)="data"&gt;
                &lt;b class="text-info"&gt;{{ data.value.last.toUpperCase() }}&lt;/b&gt;, &lt;b&gt;{{ data.value.first }}&lt;/b&gt;
            &lt;/template&gt;

            &lt;!-- A virtual composite column --&gt;
            &lt;template #cell(nameage)="data"&gt;
                {{ data.item.name.first }} is {{ data.item.age }} years old
            &lt;/template&gt;

            &lt;!-- Optional default data cell scoped slot --&gt;
            &lt;template #cell()="data"&gt;
                &lt;i&gt;{{ data.value }}&lt;/i&gt;
            &lt;/template&gt;
        &lt;/b-table&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data() {
        return {
            fields: [
                // A virtual column that doesn't exist in items
                'index',
                // A column that needs custom formatting
                { key: 'name', label: 'Full Name' },
                // A regular column
                'age',
                // A regular column
                'sex',
                // A virtual column made up from two fields
                { key: 'nameage', label: 'First name and age' }
            ],
            items: [
                { name: { first: 'John', last: 'Doe' }, sex: 'Male', age: 42 },
                { name: { first: 'Jane', last: 'Doe' }, sex: 'Female', age: 36 },
                { name: { first: 'Rubin', last: 'Kincade' }, sex: 'Male', age: 73 },
                { name: { first: 'Shirley', last: 'Partridge' }, sex: 'Female', age: 62 }
            ]
        }
    }
}
&lt;/script&gt;
```

But what if your scoped field slots of a table are [more and more](https://www.youtube.com/watch?v=mH0_XpSHkZo)? How to maintain it when you have more than thirty scoped field slots of the table?

I found that I can't use `v-bind` and `v-for` to make slots into an iterable array. Therefore, I should consider [the `render` function](https://vuejs.org/v2/guide/render-function.html).

## Second: What exactly the `render` function is

Like [React](https://reactjs.org), Vue uses [Virtual DOM](https://vuejs.org/v2/guide/render-function.html#Nodes-Trees-and-the-Virtual-DOM) to build the whole website structure from version 2.

So this code:

```vue
&lt;i class="foo"&gt;{{ value }}&lt;/i&gt;
```

Will be complied to:

```js
function (createElement) {
    return createElement("i", { class: ["foo"] }, this.value);
}
```

## Third: Exercise

But how about the table I mentioned before? Will the code in the first paragraph:

```vue
&lt;template&gt;
    &lt;div&gt;
        &lt;b-table&gt;
            &lt;template #cell(index)="data"&gt;
                {{ data.index + 1 }}
            &lt;/template&gt;
        &lt;/b-table&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;/script&gt;
```

looks like this?

```js
createElement("div", [
    createElement("b-table", { /* bypass */ }, [
        createElement("template", { "#cell(index)": "data" }, data.index + 1)
    ])
]);
```

Hint: type `npm run build` can watch the result.

## Fourth: The answer

The answer is **NO**.

Actually the code from the complied file is more like this:

```js
t("div", [
    t("b-table", {
        scopedSlots: e._u([
            {
                key: "cell(index)",
                fn: function (n) { return [e._v(" " + e._s(n.index + 1) + " ")] }
            },
        ])
    })
], 1)
```

This is a compressed code, now you know that the `#` sign in a component property means `v-slot`, which complied in the `scopedSlots` property.

And now, you know what it should looks like if put them in the render function based on [the manual](https://vuejs.org/v2/guide/render-function.html#The-Data-Object-In-Depth):

```js
{
    render: function (createElement) {
        return createElement("div", [
            createElement("b-table", {
                scopedSlots: {
                    "cell(index)": data => createElement("span", data.index + 1)
                }
            })
        ])
    }
}
```

Now you can use ["the full programmatic power of JavaScript"](https://vuejs.org/v2/guide/render-function.html):

```js
{
    render: function (createElement) {
        const scopedSlots = {
            "cell(index)": data => createElement("span", data.index + 1)
        };
        return createElement("div", [
            createElement("b-table", { scopedSlots })
        ])
    }
}
```

If you are now interested, how about turning an array to `scopedSlots` by using [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) method?

## Summary: TL;DR

1. You can use scoped field slots to render what a cell in a table should looks like.
2. The `#` sign in a component property is a shorten alias of the `v-slot` statemeny. Therefore, `#cell(index)` is a shorten alias of `v-slot:cell(index)`.
3. If you need to loop scoped field slots, consider using the `render` function.
4. Vue uses virtual DOM to complie, so does the `render` function.
5. `v-slot` uses the `scopedSlots` property in the `render` function.
