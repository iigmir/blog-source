### 序言

這幾天想知道原生 JavaScript 的生命週期到底是怎麼搞的，所以我立刻想到讀 Vue 的原始碼，來看看到底是用什麼 API 呼叫。

但我發現 Vue 的生命週期與完全原生 JavaScript 完全不一樣，不過看了原始碼也收穫頗豐啦。

### 複習一下生命週期

Vue 的生命週期有四個階段。加上階段的前與後，總共有八個階段：

|         | before        | after     |
|---------|---------------|-----------|
| create  | beforeCreate  | created   |
| mount   | beforeMount   | mounted   |
| update  | beforeUpdate  | updated   |
| destroy | beforeDestroy | destroyed |

在載入必要的生命週期與事件後，四個生命週期的發動時機分別是：

* create：載入注入（injection）、內部狀態與響應模式的前後。
* mount：繪製 HTML template 的前後。
* update：組件內部狀態更新的前後。
* destroy：組件觀察器（watcher）與事件被銷毀的前後。

![Vue 官方繪製的生命週期圖](https://vuejs.org/images/lifecycle.png)

### 啟程：Instance 的五行函式

先從 `src/core/index.js` 開始。這個檔案會帶我們進到 `src/core/instance/index.js` 檔案。跳進去以後，你會發現 Vue 執行了五個函式：

```javascript
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

你可能覺得應該會先從 `lifecycleMixin` 開始講——但我要先講的是 `initMixin` 這個函式。

### 揭露真實的自我：initMixin 做了啥

`initMixin` 這函式大約六十行左右。裡面有不少是針對環境不同所給出的措施。

重點是後面的程式碼：

```javascript
// expose real self
vm._self = vm
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

這段程式把整個過程都解釋得很清楚：在一切開始之前，先執行 `initLifecycle` `initEvents` `initRender` 這三個函式。`initLifecycle` 很簡單，就是把組件的狀態都啟動：

```javascript
// src/core/instance/lifecycle.js
export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
```

雖然我不懂為什麼這函式會叫「初始化生命週期」。

接著 `initEvents` 會讓組件開始添加監聽器。監聽器的內部運作……頗複雜的，所以暫時不看了。在 `src/core/instance/events.js` 還不夠、還需要載入 `src/core/vdom/helpers/update-listeners.js` 啥的……

`initRender` 會透過 [Virtual DOM](https://cythilya.github.io/2017/03/31/virtual-dom) 來建立組件的元素、同時藉由 `defineReactive` 開始載入 Vue 的響應式功能：

```javascript
// src/core/instance/render.js
/* 略 */
vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
/* 略 */
vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
/* 略 */
/* istanbul ignore else */
if (process.env.NODE_ENV !== 'production') {
  defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {
    !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm)
  }, true)
  defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {
    !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm)
  }, true)
} else {
  defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true)
  defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true)
}
```

附帶一題，Vue 的響應式功能可以從 `src/core/observer/index.js` 看到，裡面是由 `getOwnPropertyDescriptor` 與 `defineProperty` 完成的。

完成後，就開始呼叫 `callHook` 了。`callHook` 會呼叫對應的事件監聽器。所以這就是為什麼在 Vue 裡面寫了 `beforeCreate` 就能執行裡面的程式。

然後從 `callHook(vm, 'beforeCreate')` 到 `callHook(vm, 'created')` 之間又執行了 `initInjections` `initState` `initProvide` 三個函式。

1. 位於 src/core/instance/inject.js 的 `initInjections` 其實也是去呼叫前面提到的 `initRender`
2. 位於 `src/core/instance/state.js` 的 `initState` 則會初始化所有有寫到的 instance 像是 `props`, `methods`, `data` 之類的。不過 `computed` 不會初始化。
3. 位於 `src/core/instance/inject.js` 的 `initProvide` 則與 [inject API](https://vuejs.org/v2/api/#provide-inject) 有關。不過我沒用過所以不清楚。

啊，直到現在才把 create 階段講完。不好了不好了。不過現在已經發現一個新的函式：`callHook` 了。我們可以用這函式當各階段的分界點。
